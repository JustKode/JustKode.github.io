{"componentChunkName":"component---src-layouts-post-layout-tsx","path":"/python/pygorithm-3","result":{"data":{"markdownRemark":{"html":"<h1>Python, Algorithm, Tips</h1>\n<p><code class=\"language-text\">Python</code>은 알고리즘 문제를 해결 하는데에 <strong>강력한</strong> 언어 입니다. 하지만, <code class=\"language-text\">Python</code>으로 문제를 해결 하는 데에 익숙치 않다면, 많은 <strong>시행착오</strong>를 겪게 됩니다. 우리가 대부분 원래 사용 했던 <code class=\"language-text\">C++</code>은 <strong>컴파일 언어</strong> 입니다. 하지만, <code class=\"language-text\">Python</code>은 <strong>스크립트 언어</strong>이다 보니, 여러 가지 <strong>컴파일 에러</strong>를 겪을 수 있고, <strong>타입리스 언어</strong>기 때문에, 타입 체킹이 제대로 되지 않아, 어려움을 겪을 수도 있습니다. 하지만, 우리는 이러한 <strong>타입리스 언어, 스크립트 언어</strong>의 장점을 잘 이용해야 합니다. 타입리스 언어이자 스크립트 언어이기 때문에, 빠르게 무언가를 구현 할 수 있도록 우리에게 제공된 구현체들을 잘 이용하여야 합니다. 이제 시작하겠습니다.</p>\n<br>\n<h2>백트래킹, 브루트 포스 문제를 해결하는 도중 컴파일 에러, 혹은 <code class=\"language-text\">RuntimeError: maximum recursion depth exceeded</code> 에러가 발생합니다.</h2>\n<p><code class=\"language-text\">Python</code>에는 <strong>함수 호출 스택</strong>이라는 것이 존재합니다. A 라는 함수에서 B 라는 함수를 호출하면, B 함수가 종료 될 때 까지 A 함수를 종료 하지 않는 것이죠. 아마 <strong>백트래킹 문제</strong>, <strong>브루트 포스 문제</strong>를 해결하는 중이라면, <strong>재귀 함수</strong>를 사용 하고 있을 가능성이 높습니다. 그럼 아마 높은 확률로 두 가지 경우의 수로 해결이 가능합니다.</p>\n<ol>\n<li>재귀 함수의 종료 조건을 계속 충족하지 못하고 있다.\n이런 경우에는 <code class=\"language-text\">print()</code> 함수를 이용하여, 재귀 함수가 어떻게 돌아가는지 확인 하고, 일차적으로 문제의 접근 방법이 잘못 되었는지 체크 해 봐야 합니다.</li>\n<li>그냥 재귀 과정에서 중간에 끊겨 버리는데요...?\n기본적으로 <code class=\"language-text\">Python</code> 에서 재귀 함수가 무한정 실행 되었을 때 문제가 발생 할 것을 대비하여, <strong>최대 재귀 호출 횟수를 1000회</strong>로 제한 했습니다. 사용자가 임의적으로 최대 재귀 호출 횟수를 늘리고 싶다면 <code class=\"language-text\">sys</code> 모듈의 <code class=\"language-text\">setrecursionlimit()</code> 함수를 이용하여 조정 할 수 있습니다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\nsys<span class=\"token punctuation\">.</span>setrecursionlimit<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token operator\">**</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 10^6 만큼 최대 재귀 호출 횟수 늘림</span></code></pre></div>\n<p>그래도 안된다면... 1번으로 돌아가고, 그래도 안되면 다른 방법 찾는게 정신 건강에 좋습니다.</p>\n<br>\n<h2>특정 키 값을 이용 해서 <code class=\"language-text\">list</code>를 정렬 하고 싶어요!</h2>\n<p><code class=\"language-text\">list.sort()</code> 의 <code class=\"language-text\">key</code> 파라미터로 <code class=\"language-text\">lambda</code> 함수를 넘겨 주어, <code class=\"language-text\">element</code>의 정렬 조건을 설정 할 수 있습니다. <code class=\"language-text\">lambda</code>로 구현이 힘들다면 함수를 구현하고, <code class=\"language-text\">key</code> 파라미터로 <code class=\"language-text\">functools.cmp_to_key(함수명)</code>을 넘겨주면 됩니다. 내림차순 정렬을 원하면, <code class=\"language-text\">reverse</code> 파라미터로 <code class=\"language-text\">True</code>를 넘겨 주면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> functools <span class=\"token keyword\">import</span> cmp_to_key  <span class=\"token comment\"># cmp_to_key가 필요한 경우 import</span>\n\narr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\narr<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>key<span class=\"token operator\">=</span><span class=\"token keyword\">lambda</span> x<span class=\"token punctuation\">:</span> x<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> reverse<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 튜플 1번째 값으로 정렬</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>                 <span class=\"token comment\"># 튜플 1번째 값으로 정렬</span>\n    <span class=\"token keyword\">if</span> x<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> y<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>            <span class=\"token comment\"># 만약 1번째 값이 같다면, 0번째 값 내림차순으로 정렬</span>\n        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> y<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> y<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> x<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n        \narr<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>key<span class=\"token operator\">=</span>cmp_to_key<span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></code></pre></div>\n<p>여담으로 알려드리자면, <code class=\"language-text\">sort()</code>의 알고리즘은 <a href=\"https://en.wikipedia.org/wiki/Timsort\">Tim Sort</a> 를 사용하며, 시간 복잡도는 <strong>O(n log n)</strong> 입니다.</p>\n<br>\n<h2><code class=\"language-text\">dict</code>의 시간 복잡도</h2>\n<p><code class=\"language-text\">dict</code>는 <strong>해시 테이블</strong>을 사용 하는 자료 구조이기 때문에, 시간 복잡도가 매우 작습니다. <strong>삽입, 삭제</strong> 등의 평균 시간 복잡도가 <strong>O(1)</strong> 입니다. 하지만, <strong>데이터의 용량이 비대하게 클 경우</strong>에는 <strong>해시 테이블</strong>의 수행 속도가 급격히 낮아지고, 공간 복잡도 또한 안 좋아 지기 때문에, 신중하게 사용해 주세요.</p>\n<br>\n<h2>collections 모듈</h2>\n<p><code class=\"language-text\">collections</code> 모듈은 당신의 손목과 손가락을 보호해 줄 좋은 친구 입니다. <code class=\"language-text\">Python</code> 기본 라이브러리 이기 때문에, 속도 또한 검증 되었습니다. 구현 상의 편안함을 위한 친구이니, 굳이 찾아 보지 않아도 됩니다. 하지만, <strong>뜨거운 프로그래머들에겐 그딴거 필요없습니다.</strong> (<code class=\"language-text\">deque</code>는 필요 합니다... 하하...)</p>\n<ul>\n<li><a href=\"https://docs.python.org/3.7/library/collections.html\">collections Document</a></li>\n</ul>\n<br>\n<h2>마치며</h2>\n<p><code class=\"language-text\">Python</code>으로 문제를 푸는게 속도가 느릴 수 있다고 생각 할 수 있지만, 대부분의 대회에서는 <code class=\"language-text\">Python</code> 같은 경우 프로그램 실행 시간 제한을 조금 늘려 주는 경우도 많고, 일단, 구현체를 구현 함에 있어서 <strong>코드의 가독성</strong> 이 높기 때문에, <strong>디버깅 및 논리적 오류</strong>를 발견 하는데에 강력합니다. 알고리즘 문제를 해결 하는데에 <strong>파이썬... 한 뚝배기 어떻습니까...?</strong></p>","id":"90dc1d5c-c9c4-5f32-8680-58ad66638ded","frontmatter":{"date":"2020-03-27","path":"/python/pygorithm-3","title":"파이썬으로 알고리즘을 풀어보자! - 3. 팁","tags":["Python","Algorithm"],"keyword":"Python, python, 파이썬, Algorithm, algorithm, 알고리즘, Python Algorithm, 파이썬 알고리즘","summary":"Python, Algorithm, Tips","img":"https://miro.medium.com/max/1027/1*Ud_bNdeWPf4iN1EcydaDFA.png","series":"Python Algorithm"}}},"pageContext":{"series":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"90dc1d5c-c9c4-5f32-8680-58ad66638ded","excerpt":"Python, Algorithm, Tips…","frontmatter":{"date":"2020-03-27","tags":["Python","Algorithm"],"path":"/python/pygorithm-3","title":"파이썬으로 알고리즘을 풀어보자! - 3. 팁","img":"https://miro.medium.com/max/1027/1*Ud_bNdeWPf4iN1EcydaDFA.png","summary":"Python, Algorithm, Tips"}}},{"node":{"id":"2785be5e-423f-5687-9250-7910221425fa","excerpt":"Python…","frontmatter":{"date":"2020-03-22","tags":["Python","Algorithm"],"path":"/python/pygorithm-2","title":"파이썬으로 알고리즘을 풀어보자! - 2. 모듈","img":"https://miro.medium.com/max/1027/1*Ud_bNdeWPf4iN1EcydaDFA.png","summary":"Python의 내장 함수와 모듈"}}},{"node":{"id":"e19fe602-2f72-5872-b3c1-453adbbe61bf","excerpt":"Python…","frontmatter":{"date":"2020-03-21","tags":["Python","Algorithm"],"path":"/python/pygorithm-1","title":"파이썬으로 알고리즘을 풀어보자! - 1. 입문","img":"https://miro.medium.com/max/1027/1*Ud_bNdeWPf4iN1EcydaDFA.png","summary":"Python의 입출력에 대하여"}}}]}}},"categoryPosts":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"9ab613aa-c8ca-51f3-9420-b83c071d443f","excerpt":"Python Thread 에서는 한 프로세스에서 여러 가지 병렬 처리를 위해 를 구현 할 수 있는 를 제공 합니다. 프로그램을 여러 개로 나누지 않으며 하는 의 장점은 다음과 같습니다. 전역 변수를 이용한 메모리 공유를 통해 효율적인 메모리 사용이 가능 철저한 작업 분리 가능 코드 간결성 하지만, 단점 또한 존재합니다. 디버깅 난이도 상승 구현 난이도 상승 교착 상태가 발생하지 않도록 주의 하여야 함 Thread…","frontmatter":{"date":"2020-04-10","tags":["Python"],"path":"/python/thread","title":"Python으로 Thread 구현하기.","img":"https://i.imgur.com/CRLzESV.png","summary":"Python에서의 병렬처리 방법"}}},{"node":{"id":"ddf2f489-870b-5d07-a72f-68cefd3da0c4","excerpt":"CNN In Pytorch 에는 을 개발 하기 위한 들이 있습니다. 다채널로 구현 되어 있는 CNN 신경망을 위한 Layers, Max pooling, Avg pooling 등, 이번 시간에는 여러 가지 을 위한 를 알아 보겠습니다. 또한,  데이터 또한 학습 해 보겠습니다. Convolution Layers  연산을 위한 레이어들은 다음과 같습니다. Conv1d (Text-CNN에서 많이 사용) Conv2d…","frontmatter":{"date":"2020-04-08","tags":["Deep-Learning","Python"],"path":"/deep-learning/pytorch-cnn","title":"Pytorch로 CNN 구현하기","img":"https://3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Plot-of-a-Subset-of-Images-from-the-MNIST-Dataset-1024x768.png","summary":"Pytorch로 MNIST 그림 식별을 해보자."}}},{"node":{"id":"5b78f1ab-69ff-56fb-b9d3-f76b6905f5a1","excerpt":"Neural Network in Pytorch 딥 러닝 프레임워크인 에선 신경망 구축을 위한 API…","frontmatter":{"date":"2020-04-04","tags":["Deep-Learning","Python"],"path":"/deep-learning/pytorch-nn","title":"Pytorch의 Neural Network","img":"https://challengepost-s3-challengepost.netdna-ssl.com/photos/production/challenge_thumbnails/000/822/053/datas/original.png","summary":"Pytorch에서 신경망 구현하기"}}},{"node":{"id":"18eeab8b-863e-5ce3-b980-5e9e957c180a","excerpt":"Pytorch로 행렬을 미분해보자, autograd 딥러닝 이론에 대해서 공부 해 보신 분들은, 딥러닝의 핵심은 미분을 통해서 손실 함수(loss function)의 값을 최소화 하는 것 입니다. 그렇기 때문에 Deep Learning 연구 플랫폼인 에선, 당연하게도 행렬 미분을 위한 기능들을  객체에 내장 시켜 놓았습니다. 한 번 알아볼까요? autograd 활성화 시키기 requires_grad=True…","frontmatter":{"date":"2020-03-28","tags":["Deep-Learning","Python"],"path":"/deep-learning/pytorch-autograd","title":"Pytorch로 행렬을 미분해보자, autograd","img":"https://challengepost-s3-challengepost.netdna-ssl.com/photos/production/challenge_thumbnails/000/822/053/datas/original.png","summary":"Pytorch로 행렬을 미분하는 방법"}}}]}}}}}}