{"componentChunkName":"component---src-layouts-post-layout-tsx","path":"/cloud-computing/docker","result":{"data":{"markdownRemark":{"html":"<h2>아 ㅋㅋ 왜 여기선 되는데 거기선 안되는데</h2>\n<p>여러분들도 많이 경험 해 봤을 이슈입니다. <strong>\"아! 왜 여기선 되는데 거기선 터지는거야!\"</strong></p>\n<p>한 번 우리가 다른 사람이 작업 한 서버를 구동 할 때, 어떻게 하는지 다시 한번 되세겨 볼까요? 새 컴퓨터에 <strong>Node.js</strong> 서버를 한번 실행해 본다고 가정 하겠습니다. </p>\n<ol>\n<li><strong>Linux</strong>를 설치 한다.</li>\n<li><strong>MySQL, nginx</strong>를 설치 한다.</li>\n<li><strong>Node.js</strong>를 설치 한다.</li>\n<li><strong>환경 변수</strong>를 설정 한다.</li>\n<li>기타 등등...</li>\n</ol>\n<p>우리는 새 컴퓨터에 서버를 실행 할 때 이러한 과정들을 거칩니다. 여기서 문제가 있습니다. 사전에 서버 사양에 대한 <strong>완벽한 인수인계</strong>가 없다면, 저 위에 있는 것들이 원래 서버가 있던 컴퓨터와 완전히 똑같이 행해 질 수 있을까요?</p>\n<h2>그래서 나왔어요, 컨테이너(Container)</h2>\n<p align=\"center\">\n\t<img src=\"/post_image/docker-1/0-1.jpg\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t컨테이너의 특징, 규격화 됨, 일정함\n\t</p>\n</p>\n<h3>컨테이너 전에는 가상화</h3>\n<p>일단 <strong>Docker</strong>를 사용 하기 전에 <strong>컨테이너</strong>에 대한 설명이 선행 되어야 할 것 같습니다. 여러분, <strong>가상화</strong>라는 개념을 들어 보셨나요? <strong>가상화</strong>는 단순하게 말하면 \"<strong>물리적인 컴퓨터 리소스</strong>를 <strong>논리적인 객체</strong>로 <strong>추상화</strong>\" 하는 것입니다. 우리는 호스트 컴퓨터에서 다수의 운영체제를 동시에 실행 하게 해주는 논리적 플랫폼인 <strong>Hypervisor</strong>를 이용하여, <strong>하나의 하드웨어</strong>를 통해, <strong>여러 개의 운영체제가 접근하여 사용</strong> 할 수 있도록 할 수 있습니다. 하지만, 이는 각 운영체제에 대한 메모리, 커널 등을 따로 할당 함으로써, <strong>속도 이슈</strong>가 발생합니다.</p>\n<p align=\"center\">\n\t<img src=\"https://www.docker.com/sites/default/files/d8/2018-11/container-vm-whatcontainer_2.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<h3>컨테이너의 등장</h3>\n<p>그래서 우리에게 <strong>컨테이너(Container)</strong> 라는 것이 등장했습니다. <strong>컨테이너</strong>는 코드와 종속성을 한 곳에 묶은 <strong>애플리케이션의 추상화</strong>라고 볼 수 있으며, <strong>프로세스를 격리</strong>함으로써 동일한 시스템에서 OS 커널만을 공유합니다. 그리하여 추가적으로 컨테이너를 생성할 때, 더 필요한 <strong>CPU와 메모리를 딱 필요한 만큼만</strong> 사용하여 속도는 빠르게, 용량은 적게, 하지만 프로세스 독립성은 여러 개의 운영체제를 실행 하는 수준으로 확실히 하는 획기적인 기술입니다.</p>\n<p align=\"center\">\n\t<img src=\"https://www.docker.com/sites/default/files/d8/2018-11/docker-containerized-appliction-blue-border_2.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<h3>컨테이너의 근본이 되는 Image</h3>\n<p><strong>컨테이너</strong>와 동시에 우리는 <strong>이미지(Image)</strong> 라는 개념을 알아두어야 합니다. <strong>이미지</strong>는 컨테이너 <strong>실행에 필요한 파일, 의존성, 설정 값</strong> 등을 담고 있습니다. 쉽게 이야기 하면, <strong>컨테이너를 실행하기 위한 정보</strong>들을 담고 있다고 할 수 있습니다. <strong>컨테이너</strong>는 <strong>이미지</strong>를 기반으로 실행 되며, <a href=\"https://hub.docker.com/\">Docker Hub</a>를 통해 우리가 원하는 Image를 찾아서 쉽게 사용 할 수 있습니다. <strong>Docker Image</strong>는 대충 수백 MB에 이르는데, 만약, 우리가 <strong>nginx, Node.js, Python, MySQL</strong> 등, 많은 이미지를 다운 받게 되면 기가 단위 까지 올라가 부담이 될 수 있겠죠? 그래서 <strong>Docker</strong>에서는 이 문제를 해결 하기 위해 <strong>Layer</strong>라는 개념을 사용 합니다. 위에 언급한 모든 이미지는 <strong>Linux</strong>를 사용 합니다. 일단 <strong>리눅스 레이어</strong>를 <code class=\"language-text\">A</code> 라고 하겠습니다. 그럼 그 위에 <strong>nginx</strong> 실행 파일에 해당하는 것을 <code class=\"language-text\">B</code>, <strong>Node.js</strong> 실행 파일에 해당하는 것을 <code class=\"language-text\">C</code> 라고 하면, <strong>nginx Image</strong>는 <code class=\"language-text\">A</code> + <code class=\"language-text\">B</code>, <strong>Node.js Image</strong>는 <code class=\"language-text\">A</code> + <code class=\"language-text\">C</code> 라고 할 수 있습니다. 이러한 방식으로 용량을 최소화 할 수 있습니다.</p>\n<p align=\"center\">\n\t<img src=\"https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<h2>그래서, 처음에 이야기 한 문제는 어떻게 해결 하는 건데요?</h2>\n<p>자자, 들어보세요, 그러면 코드를 <strong>Docker 환경</strong>에서 실행 한 후에, 실행에 성공한 <strong>Image</strong>를 다른 사람들이 사용하게 하면 됩니다. 아니, 애초에 <strong>Docker 환경</strong>에서 개발을 하는 것이 베스트입니다. 이제, 우리는 <strong>Docker 환경</strong>에서 개발을 할 수 있도록, <strong>Image</strong>를 가져 오는 법, <strong>Image</strong>를 이용하여 <strong>Container</strong>를 실행하는 방법, <strong>Dockerfile</strong>를 이용해 <strong>Image</strong>를 만드는 방법, <strong>Image</strong>를 <strong>Docker Hub</strong>에 커밋하는 방법 등을 배워 볼 것입니다.</p>\n<h3>세줄 요약</h3>\n<ol>\n<li><strong>Docker</strong>는 <strong>컨테이너</strong>를 이용해 외부와 <strong>완전히 독립된 프로세스</strong>를 실행하게 해준다!</li>\n<li><strong>컨테이너</strong>는 실행에 필요한 파일, 의존성, 설정값을 담고 있는 <strong>이미지</strong>를 기반으로 실행된다.</li>\n<li>독립된 프로세스를 가상화를 통해 실행하여 느릴 것 같지만, OS 커널을 공유하여 <strong>Docker는 빠르고 가볍다!</strong></li>\n</ol>\n<p>※ 군 복무중인 관계로 다음 Docker 관련 포스팅은 2달 후에 올리겠습니다..!</p>","id":"ad0d4f5b-f203-50c2-8056-ec62bf429913","frontmatter":{"date":"2020-09-17","path":"/cloud-computing/docker","title":"Docker 시리즈 - 1. 도커, 왜 써요?","tags":["Cloud-Computing"],"keyword":"도커, docker, docker tutorial, 도커쓰는이유","summary":"도커는 왜 쓰는 거에요?","img":"/post_image/thumbnail/docker-1.jpg","series":"Docker"}}},"pageContext":{"series":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"1be02aa6-cb67-526e-89e3-dba10cceb27d","excerpt":"Review 지난 시간에는 Docker를 왜 배우는지에 대해 간단하게 알아 보았습니다. OS 커널을 공유 함으로써, 빠른 가상화가 가능하고, 완전한 프로세스 분리가 가능하며, 그 프로세스의 환경을 그대로 재현 함으로써 다른 컴퓨터에서도 오류가 안 뜨게 끔 하는 것이 Docker의 핵심 이라고 이야기 했었죠? 이제 Docker를 진짜 사용해 보는 시간을 가져 보겠습니다! Docker Install Docker 설치법은  Window Install…","frontmatter":{"date":"2021-03-20","tags":["Cloud-Computing"],"path":"/cloud-computing/docker-2","title":"Docker 시리즈 - 2. Docker Basic","img":"/post_image/thumbnail/docker-2.jpg","summary":"도커의 기본 부터 차근차근"}}},{"node":{"id":"ad0d4f5b-f203-50c2-8056-ec62bf429913","excerpt":"아 ㅋㅋ 왜 여기선 되는데 거기선 안되는데 여러분들도 많이 경험 해 봤을 이슈입니다. \"아! 왜 여기선 되는데 거기선 터지는거야!\" 한 번 우리가 다른 사람이 작업 한 서버를 구동 할 때, 어떻게 하는지 다시 한번 되세겨 볼까요? 새 컴퓨터에 Node.js 서버를 한번 실행해 본다고 가정 하겠습니다.  Linux를 설치 한다. MySQL, nginx를 설치 한다. Node.js…","frontmatter":{"date":"2020-09-17","tags":["Cloud-Computing"],"path":"/cloud-computing/docker","title":"Docker 시리즈 - 1. 도커, 왜 써요?","img":"/post_image/thumbnail/docker-1.jpg","summary":"도커는 왜 쓰는 거에요?"}}}]}}},"categoryPosts":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"50cfb865-15d8-5497-a729-a6f0f219cade","excerpt":"Docker Basic 안녕하세요? JustKode 입니다. 오늘은 컨테이너 기술을 구현하기 위한 Docker…","frontmatter":{"date":"2021-08-02","tags":["Cloud-Computing"],"path":"/data-science/just-cloud-computing-5","title":"[찍먹 Cloud Computing] 5. Docker Image, Container, Dockerfile","img":"/post_image/thumbnail/just-cloud-computing-5.jpg","summary":"도커의 기본 사용법에 대해서 알아보자."}}},{"node":{"id":"e58c367b-3d1b-5b9c-92c0-5870c9da1843","excerpt":"AWS의 Database 안녕하세요? Justkode 입니다. 이번 시간에는 AWS의 Database에 대해서 공부 해 보는 시간을 가져 보도록 하겠습니다. AWS에서 사용하는 Database는 두 가지가 있습니다. DynamoDB 첫 번째는 DynamoDB 입니다. 이는 AWS의 대표격으로 사용 되는 데이터베이스이며, NoSQL Database 중 하나 입니다. 여기서 NoSQL은 무엇이냐 하면, 말 그대로 표준 SQL…","frontmatter":{"date":"2021-07-27","tags":["Cloud-Computing"],"path":"/data-science/just-cloud-computing-4","title":"[찍먹 Cloud Computing] 4. DynamoDB & Amazon RDS","img":"/post_image/thumbnail/just-cloud-computing-4.jpg","summary":"두 개의 대표적인 AWS DB를 공부 해 보자"}}},{"node":{"id":"dff6db0e-6cfa-5f45-a152-6462e539d9af","excerpt":"AWS Lambda 안녕하세요? Justkode 입니다. 이번 시간에는 AWS Lambda에 대해서 알아 보고, AWS Lambda 함수를 생성 해 보고, 이를 AWS API Gateway를 통해 연결 하여 사용 해 보는 시간을 가져 보도록 하겠습니다. AWS Lambda에 대해서 간단하게 설명 하고 넘어 가자면, PaaS (Platform As A Service)의 일종으로, 우리가 AWS Lambda에 우리가 구현한 API Code…","frontmatter":{"date":"2021-07-21","tags":["Cloud-Computing"],"path":"/data-science/just-cloud-computing-3","title":"[찍먹 Cloud Computing] 3. AWS Lambda","img":"/post_image/thumbnail/just-cloud-computing-3.jpg","summary":"Python 기반으로 AWS Lambda 함수를 만들어보자."}}},{"node":{"id":"26cf793d-aefa-5dbf-97d1-7dea7275eba7","excerpt":"AWS S3 안녕하세요? Justkode 입니다. 이번 시간에는 AWS S3에 대해서 알아 보고, AWS S3 버킷 생성, 파일 접근 권한 설정, Python 코드 상에서의 접근을 해 보도록 하겠습니다. 일단 AWS S3에 대해서 간단하게 설명 드리겠습니다. AWS S…","frontmatter":{"date":"2021-07-16","tags":["Cloud-Computing","Python"],"path":"/data-science/just-cloud-computing-2","title":"[찍먹 Cloud Computing] 2. AWS S3","img":"/post_image/thumbnail/just-cloud-computing-2.jpg","summary":"AWS S3와 boto3를 사용 해 보자"}}}]}}}}},"staticQueryHashes":["234633779","63159454"]}