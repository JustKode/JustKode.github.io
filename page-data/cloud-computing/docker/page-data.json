{"componentChunkName":"component---src-layouts-post-layout-tsx","path":"/cloud-computing/docker/","result":{"data":{"markdownRemark":{"html":"<h2>아 ㅋㅋ 왜 여기선 되는데 거기선 안되는데</h2>\n<p>여러분들도 많이 경험 해 봤을 이슈입니다. <strong>\"아! 왜 여기선 되는데 거기선 터지는거야!\"</strong></p>\n<p>한 번 우리가 다른 사람이 작업 한 서버를 구동 할 때, 어떻게 하는지 다시 한번 되세겨 볼까요? 새 컴퓨터에 <strong>Node.js</strong> 서버를 한번 실행해 본다고 가정 하겠습니다.</p>\n<ol>\n<li><strong>Linux</strong>를 설치 한다.</li>\n<li><strong>MySQL, nginx</strong>를 설치 한다.</li>\n<li><strong>Node.js</strong>를 설치 한다.</li>\n<li><strong>환경 변수</strong>를 설정 한다.</li>\n<li>기타 등등...</li>\n</ol>\n<p>우리는 새 컴퓨터에 서버를 실행 할 때 이러한 과정들을 거칩니다. 여기서 문제가 있습니다. 사전에 서버 사양에 대한 <strong>완벽한 인수인계</strong>가 없다면, 저 위에 있는 것들이 원래 서버가 있던 컴퓨터와 완전히 똑같이 행해 질 수 있을까요?</p>\n<h2>그래서 나왔어요, 컨테이너(Container)</h2>\n<p align=\"center\">\n\t<img src=\"/post_image/docker-1/0-1.jpg\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t컨테이너의 특징, 규격화 됨, 일정함\n\t</p>\n</p>\n<h3>컨테이너 전에는 가상화</h3>\n<p>일단 <strong>Docker</strong>를 사용 하기 전에 <strong>컨테이너</strong>에 대한 설명이 선행 되어야 할 것 같습니다. 여러분, <strong>가상화</strong>라는 개념을 들어 보셨나요? <strong>가상화</strong>는 단순하게 말하면 \"<strong>물리적인 컴퓨터 리소스</strong>를 <strong>논리적인 객체</strong>로 <strong>추상화</strong>\" 하는 것입니다. 우리는 호스트 컴퓨터에서 다수의 운영체제를 동시에 실행 하게 해주는 논리적 플랫폼인 <strong>Hypervisor</strong>를 이용하여, <strong>하나의 하드웨어</strong>를 통해, <strong>여러 개의 운영체제가 접근하여 사용</strong> 할 수 있도록 할 수 있습니다. 하지만, 이는 각 운영체제에 대한 메모리, 커널 등을 따로 할당 함으로써, <strong>속도 이슈</strong>가 발생합니다.</p>\n<p align=\"center\">\n\t<img src=\"https://www.docker.com/sites/default/files/d8/2018-11/container-vm-whatcontainer_2.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<h3>컨테이너의 등장</h3>\n<p>그래서 우리에게 <strong>컨테이너(Container)</strong> 라는 것이 등장했습니다. <strong>컨테이너</strong>는 코드와 종속성을 한 곳에 묶은 <strong>애플리케이션의 추상화</strong>라고 볼 수 있으며, <strong>프로세스를 격리</strong>함으로써 동일한 시스템에서 OS 커널만을 공유합니다. 그리하여 추가적으로 컨테이너를 생성할 때, 더 필요한 <strong>CPU와 메모리를 딱 필요한 만큼만</strong> 사용하여 속도는 빠르게, 용량은 적게, 하지만 프로세스 독립성은 여러 개의 운영체제를 실행 하는 수준으로 확실히 하는 획기적인 기술입니다.</p>\n<p align=\"center\">\n\t<img src=\"https://www.docker.com/sites/default/files/d8/2018-11/docker-containerized-appliction-blue-border_2.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<h3>컨테이너의 근본이 되는 Image</h3>\n<p><strong>컨테이너</strong>와 동시에 우리는 <strong>이미지(Image)</strong> 라는 개념을 알아두어야 합니다. <strong>이미지</strong>는 컨테이너 <strong>실행에 필요한 파일, 의존성, 설정 값</strong> 등을 담고 있습니다. 쉽게 이야기 하면, <strong>컨테이너를 실행하기 위한 정보</strong>들을 담고 있다고 할 수 있습니다. <strong>컨테이너</strong>는 <strong>이미지</strong>를 기반으로 실행 되며, <a href=\"https://hub.docker.com/\">Docker Hub</a>를 통해 우리가 원하는 Image를 찾아서 쉽게 사용 할 수 있습니다. <strong>Docker Image</strong>는 대충 수백 MB에 이르는데, 만약, 우리가 <strong>nginx, Node.js, Python, MySQL</strong> 등, 많은 이미지를 다운 받게 되면 기가 단위 까지 올라가 부담이 될 수 있겠죠? 그래서 <strong>Docker</strong>에서는 이 문제를 해결 하기 위해 <strong>Layer</strong>라는 개념을 사용 합니다. 위에 언급한 모든 이미지는 <strong>Linux</strong>를 사용 합니다. 일단 <strong>리눅스 레이어</strong>를 <code class=\"language-text\">A</code> 라고 하겠습니다. 그럼 그 위에 <strong>nginx</strong> 실행 파일에 해당하는 것을 <code class=\"language-text\">B</code>, <strong>Node.js</strong> 실행 파일에 해당하는 것을 <code class=\"language-text\">C</code> 라고 하면, <strong>nginx Image</strong>는 <code class=\"language-text\">A</code> + <code class=\"language-text\">B</code>, <strong>Node.js Image</strong>는 <code class=\"language-text\">A</code> + <code class=\"language-text\">C</code> 라고 할 수 있습니다. 이러한 방식으로 용량을 최소화 할 수 있습니다.</p>\n<p align=\"center\">\n\t<img src=\"https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<h2>그래서, 처음에 이야기 한 문제는 어떻게 해결 하는 건데요?</h2>\n<p>자자, 들어보세요, 그러면 코드를 <strong>Docker 환경</strong>에서 실행 한 후에, 실행에 성공한 <strong>Image</strong>를 다른 사람들이 사용하게 하면 됩니다. 아니, 애초에 <strong>Docker 환경</strong>에서 개발을 하는 것이 베스트입니다. 이제, 우리는 <strong>Docker 환경</strong>에서 개발을 할 수 있도록, <strong>Image</strong>를 가져 오는 법, <strong>Image</strong>를 이용하여 <strong>Container</strong>를 실행하는 방법, <strong>Dockerfile</strong>를 이용해 <strong>Image</strong>를 만드는 방법, <strong>Image</strong>를 <strong>Docker Hub</strong>에 커밋하는 방법 등을 배워 볼 것입니다.</p>\n<h3>세줄 요약</h3>\n<ol>\n<li><strong>Docker</strong>는 <strong>컨테이너</strong>를 이용해 외부와 <strong>완전히 독립된 프로세스</strong>를 실행하게 해준다!</li>\n<li><strong>컨테이너</strong>는 실행에 필요한 파일, 의존성, 설정값을 담고 있는 <strong>이미지</strong>를 기반으로 실행된다.</li>\n<li>독립된 프로세스를 가상화를 통해 실행하여 느릴 것 같지만, OS 커널을 공유하여 <strong>Docker는 빠르고 가볍다!</strong></li>\n</ol>\n<p>※ 군 복무중인 관계로 다음 Docker 관련 포스팅은 2달 후에 올리겠습니다..!</p>","id":"38ecf034-ac57-50d1-9366-094c556e2273","frontmatter":{"date":"2020-09-17","path":"/cloud-computing/docker","title":"Docker 시리즈 - 1. 도커, 왜 써요?","tags":["Cloud-Computing"],"keyword":"도커, docker, docker tutorial, 도커쓰는이유","summary":"도커는 왜 쓰는 거에요?","img":"/post_image/thumbnail/docker-1.jpg","series":"Docker"}}},"pageContext":{"postPath":"/cloud-computing/docker","series":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"fba5ff85-720f-56c1-a7e0-a9d6d159fb63","excerpt":"Review 지난 시간에는 Docker를 왜 배우는지에 대해 간단하게 알아 보았습니다. OS 커널을 공유 함으로써, 빠른 가상화가 가능하고, 완전한 프로세스 분리가 가능하며, 그 프로세스의 환경을 그대로 재현 함으로써 다른 컴퓨터에서도 오류가 안 뜨게 끔 하는 것이 Docker의 핵심 이라고 이야기 했었죠? 이제 Docker를 진짜 사용해 보는 시간을 가져 보겠습니다! Docker Install Docker 설치법은 Window Install…","frontmatter":{"date":"2021-03-20","tags":["Cloud-Computing"],"path":"/cloud-computing/docker-2","title":"Docker 시리즈 - 2. Docker Basic","img":"/post_image/thumbnail/docker-2.jpg","summary":"도커의 기본 부터 차근차근"}}},{"node":{"id":"38ecf034-ac57-50d1-9366-094c556e2273","excerpt":"아 ㅋㅋ 왜 여기선 되는데 거기선 안되는데 여러분들도 많이 경험 해 봤을 이슈입니다. \"아! 왜 여기선 되는데 거기선 터지는거야!\" 한 번 우리가 다른 사람이 작업 한 서버를 구동 할 때, 어떻게 하는지 다시 한번 되세겨 볼까요? 새 컴퓨터에 Node.js 서버를 한번 실행해 본다고 가정 하겠습니다. Linux를 설치 한다. MySQL, nginx를 설치 한다. Node.js…","frontmatter":{"date":"2020-09-17","tags":["Cloud-Computing"],"path":"/cloud-computing/docker","title":"Docker 시리즈 - 1. 도커, 왜 써요?","img":"/post_image/thumbnail/docker-1.jpg","summary":"도커는 왜 쓰는 거에요?"}}}]}}},"categoryPosts":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"f55c467d-2b09-54d6-bc08-b0b08f536b86","excerpt":"안녕하세요? 오늘은 Kubernetes를 구동 시키기 위해서 필요한 기본적인 Components들에 대해서 요약해서 알아보는 시간을 가져 보도록 하겠습니다. (글 매우 짧고, 성의 없음 주의) Control Plane Component…","frontmatter":{"date":"2023-04-24","tags":["Cloud-Computing"],"path":"/cloud-computing/k8s-components","title":"Kubernetes Component 요약","img":"/post_image/thumbnail/k8s-components.png","summary":"k8s의 컴포넌트를 초간단 요약 해 보자."}}},{"node":{"id":"7611f6af-dc48-595b-8866-23beee4d5cda","excerpt":"저번 시간에는 Spark On Kubernetes에 대한 이론을 배웠습니다. 오늘은 Spark On Kubernetes에 대한 실습을 진행 하도록 하겠습니다. 사전 준비 Docker Minikube (Kubernetes 1.20 버전 이상) kubectl Spark 3.0 버전 이상 최신 버전일 수록 좋습니다. 얼마 전에 구형 Docker가 깔려 있는 맥북에서 진행을 해 봤는데 Pod이 생성이 안되더군요.. Pyspark Image Build…","frontmatter":{"date":"2023-03-30","tags":["Data-Engineering","Cloud-Computing"],"path":"/data-engineering/spark-on-k8s-2","title":"Spark on Kubernetes - Practice","img":"/post_image/thumbnail/spark-on-k8s-2.png","summary":"Spark를 Kubernetes Cluster에서 동작 시켜 보자."}}},{"node":{"id":"3a543178-c1c9-5cfb-9c9e-b89aed5e8ead","excerpt":"안녕하세요? 오늘은 Kubernetes 환경에 JupyterHub를 설치 하는 방법에 대해서 알아 보도록 하겠습니다. Kubernetes Kubernetes는 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 Container Orchestration Tool 입니다. Kubernetes 시스템을 통해, 다음을 제공 받을 수 있습니다. 서비스 디스커버리와 로드 밸런싱: DNS 이름, 혹은 자체 IP…","frontmatter":{"date":"2023-03-25","tags":["Data-Engineering","Cloud-Computing"],"path":"/data-engineering/jupyterhub-on-k8s","title":"Jupyterhub on Kubernetes","img":"/post_image/thumbnail/jupyterhub-on-k8s.jpg","summary":"Jupyterhub를 Kubernetes Cluster에서 실행 해 보자."}}},{"node":{"id":"6108ea9c-22bb-5693-995b-aebd5cfb3bcf","excerpt":"Spark Apache Spark는 기존 Hadoop의 MapReduce 형태의 클러스터 컴퓨팅의 단점을 보완하기 위해 탄생한 프레임워크 입니다. 기존 하둡의 MapReduce에서는 Disk에서 데이터를 읽은 후, Mapping, Shuffling, Reducing의 과정을 거쳐서, 다시 Disk에 저장하는 형식으로 진행 되는데요, 이는 Disk I/O가 자주 발생 하기 때문에, 속도가 상대적으로 느리다는 단점이 있습니다. 하지만 Apache…","frontmatter":{"date":"2023-03-06","tags":["Data-Engineering","Cloud-Computing"],"path":"/data-engineering/spark-on-k8s-1","title":"Spark on Kubernetes - Concept","img":"/post_image/thumbnail/spark-on-k8s-1.jpeg","summary":"Spark를 Kubernetes Cluster에서 동작 시켜 보자."}}}]}}}}},"staticQueryHashes":["2876327880","63159454"],"slicesMap":{}}