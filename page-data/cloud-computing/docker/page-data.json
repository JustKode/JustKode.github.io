{"componentChunkName":"component---src-layouts-post-layout-tsx","path":"/cloud-computing/docker","result":{"data":{"markdownRemark":{"html":"<h2>아 ㅋㅋ 왜 여기선 되는데 거기선 안되는데</h2>\n<p>여러분들도 많이 경험 해 봤을 이슈입니다. <strong>\"아! 왜 여기선 되는데 거기선 터지는거야!\"</strong></p>\n<p>한 번 우리가 다른 사람이 작업 한 서버를 구동 할 때, 어떻게 하는지 다시 한번 되세겨 볼까요? 새 컴퓨터에 <strong>Node.js</strong> 서버를 한번 실행해 본다고 가정 하겠습니다. </p>\n<ol>\n<li><strong>Linux</strong>를 설치 한다.</li>\n<li><strong>MySQL, nginx</strong>를 설치 한다.</li>\n<li><strong>Node.js</strong>를 설치 한다.</li>\n<li><strong>환경 변수</strong>를 설정 한다.</li>\n<li>기타 등등...</li>\n</ol>\n<p>우리는 새 컴퓨터에 서버를 실행 할 때 이러한 과정들을 거칩니다. 여기서 문제가 있습니다. 사전에 서버 사양에 대한 <strong>완벽한 인수인계</strong>가 없다면, 저 위에 있는 것들이 원래 서버가 있던 컴퓨터와 완전히 똑같이 행해 질 수 있을까요?</p>\n<h2>그래서 나왔어요, 컨테이너(Container)</h2>\n<p align=\"center\">\n\t<img src=\"/post_image/docker-1/0-1.jpg\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t컨테이너의 특징, 규격화 됨, 일정함\n\t</p>\n</p>\n<h3>컨테이너 전에는 가상화</h3>\n<p>일단 <strong>Docker</strong>를 사용 하기 전에 <strong>컨테이너</strong>에 대한 설명이 선행 되어야 할 것 같습니다. 여러분, <strong>가상화</strong>라는 개념을 들어 보셨나요? <strong>가상화</strong>는 단순하게 말하면 \"<strong>물리적인 컴퓨터 리소스</strong>를 <strong>논리적인 객체</strong>로 <strong>추상화</strong>\" 하는 것입니다. 우리는 호스트 컴퓨터에서 다수의 운영체제를 동시에 실행 하게 해주는 논리적 플랫폼인 <strong>Hypervisor</strong>를 이용하여, <strong>하나의 하드웨어</strong>를 통해, <strong>여러 개의 운영체제가 접근하여 사용</strong> 할 수 있도록 할 수 있습니다. 하지만, 이는 각 운영체제에 대한 메모리, 커널 등을 따로 할당 함으로써, <strong>속도 이슈</strong>가 발생합니다.</p>\n<p align=\"center\">\n\t<img src=\"https://www.docker.com/sites/default/files/d8/2018-11/container-vm-whatcontainer_2.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<h3>컨테이너의 등장</h3>\n<p>그래서 우리에게 <strong>컨테이너(Container)</strong> 라는 것이 등장했습니다. <strong>컨테이너</strong>는 코드와 종속성을 한 곳에 묶은 <strong>애플리케이션의 추상화</strong>라고 볼 수 있으며, <strong>프로세스를 격리</strong>함으로써 동일한 시스템에서 OS 커널만을 공유합니다. 그리하여 추가적으로 컨테이너를 생성할 때, 더 필요한 <strong>CPU와 메모리를 딱 필요한 만큼만</strong> 사용하여 속도는 빠르게, 용량은 적게, 하지만 프로세스 독립성은 여러 개의 운영체제를 실행 하는 수준으로 확실히 하는 획기적인 기술입니다.</p>\n<p align=\"center\">\n\t<img src=\"https://www.docker.com/sites/default/files/d8/2018-11/docker-containerized-appliction-blue-border_2.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<h3>컨테이너의 근본이 되는 Image</h3>\n<p><strong>컨테이너</strong>와 동시에 우리는 <strong>이미지(Image)</strong> 라는 개념을 알아두어야 합니다. <strong>이미지</strong>는 컨테이너 <strong>실행에 필요한 파일, 의존성, 설정 값</strong> 등을 담고 있습니다. 쉽게 이야기 하면, <strong>컨테이너를 실행하기 위한 정보</strong>들을 담고 있다고 할 수 있습니다. <strong>컨테이너</strong>는 <strong>이미지</strong>를 기반으로 실행 되며, <a href=\"https://hub.docker.com/\">Docker Hub</a>를 통해 우리가 원하는 Image를 찾아서 쉽게 사용 할 수 있습니다. <strong>Docker Image</strong>는 대충 수백 MB에 이르는데, 만약, 우리가 <strong>nginx, Node.js, Python, MySQL</strong> 등, 많은 이미지를 다운 받게 되면 기가 단위 까지 올라가 부담이 될 수 있겠죠? 그래서 <strong>Docker</strong>에서는 이 문제를 해결 하기 위해 <strong>Layer</strong>라는 개념을 사용 합니다. 위에 언급한 모든 이미지는 <strong>Linux</strong>를 사용 합니다. 일단 <strong>리눅스 레이어</strong>를 <code class=\"language-text\">A</code> 라고 하겠습니다. 그럼 그 위에 <strong>nginx</strong> 실행 파일에 해당하는 것을 <code class=\"language-text\">B</code>, <strong>Node.js</strong> 실행 파일에 해당하는 것을 <code class=\"language-text\">C</code> 라고 하면, <strong>nginx Image</strong>는 <code class=\"language-text\">A</code> + <code class=\"language-text\">B</code>, <strong>Node.js Image</strong>는 <code class=\"language-text\">A</code> + <code class=\"language-text\">C</code> 라고 할 수 있습니다. 이러한 방식으로 용량을 최소화 할 수 있습니다.</p>\n<p align=\"center\">\n\t<img src=\"https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<h2>그래서, 처음에 이야기 한 문제는 어떻게 해결 하는 건데요?</h2>\n<p>자자, 들어보세요, 그러면 코드를 <strong>Docker 환경</strong>에서 실행 한 후에, 실행에 성공한 <strong>Image</strong>를 다른 사람들이 사용하게 하면 됩니다. 아니, 애초에 <strong>Docker 환경</strong>에서 개발을 하는 것이 베스트입니다. 이제, 우리는 <strong>Docker 환경</strong>에서 개발을 할 수 있도록, <strong>Image</strong>를 가져 오는 법, <strong>Image</strong>를 이용하여 <strong>Container</strong>를 실행하는 방법, <strong>Dockerfile</strong>를 이용해 <strong>Image</strong>를 만드는 방법, <strong>Image</strong>를 <strong>Docker Hub</strong>에 커밋하는 방법 등을 배워 볼 것입니다.</p>\n<h3>세줄 요약</h3>\n<ol>\n<li><strong>Docker</strong>는 <strong>컨테이너</strong>를 이용해 외부와 <strong>완전히 독립된 프로세스</strong>를 실행하게 해준다!</li>\n<li><strong>컨테이너</strong>는 실행에 필요한 파일, 의존성, 설정값을 담고 있는 <strong>이미지</strong>를 기반으로 실행된다.</li>\n<li>독립된 프로세스를 가상화를 통해 실행하여 느릴 것 같지만, OS 커널을 공유하여 <strong>Docker는 빠르고 가볍다!</strong></li>\n</ol>\n<p>※ 군 복무중인 관계로 다음 Docker 관련 포스팅은 2달 후에 올리겠습니다..!</p>","id":"c4cb2ec4-3067-5ab8-b247-2e8157c1f653","frontmatter":{"date":"2020-09-17","path":"/cloud-computing/docker","title":"Docker 시리즈 - 1. 도커, 왜 써요?","tags":["Cloud-Computing"],"keyword":"도커, docker, docker tutorial, 도커쓰는이유","summary":"도커는 왜 쓰는 거에요?","img":"/post_image/thumbnail/docker-1.jpg","series":"Docker"}}},"pageContext":{"series":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"c4cb2ec4-3067-5ab8-b247-2e8157c1f653","excerpt":"아 ㅋㅋ 왜 여기선 되는데 거기선 안되는데 여러분들도 많이 경험 해 봤을 이슈입니다. \"아! 왜 여기선 되는데 거기선 터지는거야!\" 한 번 우리가 다른 사람이 작업 한 서버를 구동 할 때, 어떻게 하는지 다시 한번 되세겨 볼까요? 새 컴퓨터에 Node.js 서버를 한번 실행해 본다고 가정 하겠습니다.  Linux를 설치 한다. MySQL, nginx를 설치 한다. Node.js…","frontmatter":{"date":"2020-09-17","tags":["Cloud-Computing"],"path":"/cloud-computing/docker","title":"Docker 시리즈 - 1. 도커, 왜 써요?","img":"/post_image/thumbnail/docker-1.jpg","summary":"도커는 왜 쓰는 거에요?"}}}]}}},"categoryPosts":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"c4cb2ec4-3067-5ab8-b247-2e8157c1f653","excerpt":"아 ㅋㅋ 왜 여기선 되는데 거기선 안되는데 여러분들도 많이 경험 해 봤을 이슈입니다. \"아! 왜 여기선 되는데 거기선 터지는거야!\" 한 번 우리가 다른 사람이 작업 한 서버를 구동 할 때, 어떻게 하는지 다시 한번 되세겨 볼까요? 새 컴퓨터에 Node.js 서버를 한번 실행해 본다고 가정 하겠습니다.  Linux를 설치 한다. MySQL, nginx를 설치 한다. Node.js…","frontmatter":{"date":"2020-09-17","tags":["Cloud-Computing"],"path":"/cloud-computing/docker","title":"Docker 시리즈 - 1. 도커, 왜 써요?","img":"/post_image/thumbnail/docker-1.jpg","summary":"도커는 왜 쓰는 거에요?"}}}]}}}}},"staticQueryHashes":["234633779","63159454"]}