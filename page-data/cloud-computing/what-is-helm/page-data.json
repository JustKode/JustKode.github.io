{"componentChunkName":"component---src-layouts-post-layout-tsx","path":"/cloud-computing/what-is-helm/","result":{"data":{"markdownRemark":{"html":"<h3>Intro</h3>\n<p>안녕하세요! <strong>JustKode, 박민재</strong>입니다. 오늘은 K8S Package Manager인 <strong>Helm</strong>에 대해 알아 보도록 하겠습니다.</p>\n<p>우리는 K8S로 서비스를 서빙하기 위해, k8s yaml 파일을 이용하여, K8S Resource (<code class=\"language-text\">deployment</code>, <code class=\"language-text\">pod</code>, <code class=\"language-text\">configmap</code>, <code class=\"language-text\">secret</code>, <code class=\"language-text\">service</code>, <code class=\"language-text\">persistent volume</code> 등)를 관리 하게 됩니다. 하지만, 우리는 실제 서비스를 운영 하는데 다음과 같은 상황을 마주치게 됩니다.</p>\n<ul>\n<li><strong>여러 개의 K8S Resource</strong>를 <strong>K8S Cluster에 등록</strong> 해야 하는데, 그 때 마다 직접 입력 하거나, Shell Script를 이용 해야 하는가?</li>\n<li>Beta, Prod 환경을 구성하는 데 있어, 사실상 리소스의 일부 값만 다르게 사용하게 되는데, <strong>이를 위해 똑같은 YAML File을 두개를 만들어서 관리</strong> 해야 하는가?</li>\n<li>K8S에 서비스를 배포 할 시, <strong>Rollback</strong>이 필요 한 상황에는 어떻게 대응 해야 하는가?</li>\n</ul>\n<p>그렇죠. K8S로 서비스를 서빙 하기 위해서는 많은 YAML 파일들을 등록 해 줘야 하는 과정들이 필요 합니다. 리소스별로 분리 되어 있는 여러 개의 YAML 파일들을 관리 하는 것은 매우 귀찮은 일입니다.</p>\n<h3>So, Use helm.</h3>\n<p>이를 위해, <strong>Helm</strong>이라는 친구가 등장 했습니다. <strong>Helm</strong>은 <strong>Kubernetes</strong>를 위한 <strong>Package Manager</strong>입니다. 여러 개의 K8S Resource를 관리 하기 위해 이들을 <code class=\"language-text\">helm chart</code> 라는 개념으로 묶어, public 혹은 private repo에 push 하고, <code class=\"language-text\">helm</code> CLI를 통해서, <code class=\"language-text\">helm chart</code>에 있는 메타 데이터를 바탕으로, 여러 개의 K8S Resource를 한 번에 K8S Cluster 내에 배포 할 수 있습니다.</p>\n<p>Helm은 큰 세 가지의 개념을 가지고 있습니다.</p>\n<ul>\n<li><strong>Chart</strong>: Chart는 Helm Package 입니다. Kubernetes Cluster 내에 적용할 <strong>Kubernetes Resource 정보</strong>들이 들어 가 있습니다. 어떤 Docker Image를 사용할 지, 얼마만큼의 Resource를 사용 할 지, 어떤 file을 Configmap, Secret에 등록 할 지 등의 정보를 가지고 있습니다.</li>\n<li><strong>Repository</strong>: <strong>Chart가 저장 되고, 공유 될 위치</strong>입니다. Docker Hub를 생각 하시면 편합니다. (Private 하게도, Public 하게도 운영 가능 합니다.)</li>\n<li><strong>Release</strong>: K8S Cluster에 배포 된 <strong>Chart의 Instance</strong> 입니다. <strong>하나의 Chart</strong>는 <strong>여러 개의 Cluster, Namespace</strong>내에 <strong>install</strong> (Chart의 Metadata를 바탕으로 K8S Cluster에 K8S Resource를 적용 하는 것) 될 수 있는데요, <strong>install 시마다 Release가 생성</strong> 됩니다. 만약 Chart 내의 값을 변경하여 install 하였을 때 문제가 생겼다면, Helm의 기능을 이용하여 이전 Release로 Rollback 할 수도 있는 것이죠.</li>\n</ul>\n<p>여러분이 <code class=\"language-text\">helm</code>이 설치되어 있는 상태로 <code class=\"language-text\">helm create my_chart</code>를 bash에 입력 한다면 다음과 같이 폴더가 생성 될 것 입니다. 개발자들은 <code class=\"language-text\">templates</code> 폴더 내에 <strong>k8s Resource의 Template</strong>을 작성 하고, <code class=\"language-text\">values.yaml</code>에 Template에 들어갈 <strong>Value들을 작성</strong>하는 형태로 Helm Chart를 사용할 수 있어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">my_chart/\n├── .helmignore   # Contains patterns to ignore when packaging Helm charts.\n├── Chart.yaml    # Information about your chart\n├── values.yaml   # The default values for your templates\n├── charts/       # Charts that this chart depends on\n└── templates/    # The template files\n    └── tests/    # The test files</code></pre></div>\n<h3>Feature of Helm</h3>\n<p>일단, Helm을 이용 하기 위해서는 다음이 필요 합니다.</p>\n<ul>\n<li><strong>Kubernetes Cluster</strong>가 구성 되어 있어야 합니다. (로컬 개발로는 minikube도 추천 드립니다.)</li>\n<li><code class=\"language-text\">kubectl</code>이 설치 되어 있어야 합니다.</li>\n<li>(당연하게도) <code class=\"language-text\">helm</code>이 <a href=\"https://helm.sh/docs/helm/helm_install/\">설치</a> 되어야 합니다.</li>\n</ul>\n<p>Helm에서 제공 해 주는 기능은 다음과 같습니다.</p>\n<h4>Template Engine</h4>\n<p>Helm에서는 <strong>Template Engine을 제공</strong> 합니다. 만약, 비슷한 설정을 공유하는 여러 개의 어플리케이션이 있다고 가정 하겠습니다. (백엔드 분들은 Microservice를, 데이터 엔지니어 분들은 Streaming Application을 상상해 보세요.)</p>\n<p>예를 들어, 우리가 가동 하려고 하는 어떤 어플리케이션은 Beta, Prod 환경에서 동일한 로직으로 동작 하는 대신, 바라보는 <strong>DBMS 설정, Resource 설정이 다르다</strong>고 가정 하겠습니다. Helm이 없다면, Beta용 Resource YAML 파일과, Prod용 Resource용 YAML 파일, 두 벌을 만들어야 겠군요.</p>\n<p>하지만, Helm은 Resource에 대해서 Template만 잘 만들어 놓는 다면, <strong>Value만 다르게 적용</strong>하여 K8S Resource를 배포 할 수 있습니다.</p>\n<p>예를 들어, 다음과 같은 <code class=\"language-text\">pod.yaml</code> 파일이 있다고 가정 하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> .Values.name <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> .Values.container.name <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\t<span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> .Values.container.image <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\t<span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n\t  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">containerPort</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> .Values.container.port <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 Beta 환경에는 Beta에 맞는 Resource를, Prod 환경에는 Prod에 맞는 Resource를 사용 하고 싶다면, Beta와 Prod별의 Value가 들어가 있는 YAML 파일을 적용하거나, CLI 상에서 Value를 적용 할 수 있습니다.</p>\n<ul>\n<li>yaml에 Value를 적용하는 방식</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ helm <span class=\"token function\">install</span> <span class=\"token parameter variable\">-f</span> beta_values.yaml beta_chart ./chart</code></pre></div>\n<ul>\n<li>CLI에 Value를 적용하는 방식</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ helm <span class=\"token function\">install</span> <span class=\"token parameter variable\">--set</span> <span class=\"token assign-left variable\">container.image</span><span class=\"token operator\">=</span>beta_image:1.0 <span class=\"token punctuation\">..</span>. beta_chart ./chart</code></pre></div>\n<p align=\"center\">\n\t<img src=\"/post_image/what-is-helm/01-01.png\" width=\"40%\"/>\n\t<div align=\"center\">\n\t\t유사한 K8S Resource에 대해서, 세부 Value만 다르게 여러 개의 Resource에 적용 했을 때\n\t</div>\n</p>\n<h4>Release Managing</h4>\n<p>Helm은 <strong>Release Manging</strong>이라는 기능을 가지고 있는데요, 이를 통해서, K8S Cluster 내에 설치 되어 있는 Chart를 쉽게 <strong>Upgrade</strong>하고, <strong>Rollback</strong>을 수행 할 수 있습니다.</p>\n<p>우선 install 된 Chart에 대해서 설정된 Value나 Template의 변화가 있을 경우, <code class=\"language-text\">helm upgrade</code>를 통해서 이를 <strong>K8S Cluster</strong> 내의 <strong>Helm Release</strong>에 적용 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ helm <span class=\"token function\">install</span> <span class=\"token parameter variable\">-f</span> beta_values.yaml beta_chart ./chart\n$ helm upgrade <span class=\"token parameter variable\">--install</span> <span class=\"token parameter variable\">-f</span> beta_values.yaml beta_chart ./chart  <span class=\"token comment\"># Release Name이 존재 하면 Upgrade, 없으면 Install</span></code></pre></div>\n<p>또한, Upgrade시 문제가 발생했다면, 빠르게 Rollback 하는 기능 또한 제공 해 주고 있습니다. <code class=\"language-text\">helm history</code>를 통해 Release를 확인 하고, <code class=\"language-text\">helm rollback</code>을 통해서 원하는 Revision으로 Rollback을 수행 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ helm <span class=\"token function\">history</span> my_chart\nREVISION\tUPDATED                 \tSTATUS    \tCHART        \tAPP VERSION\tDESCRIPTION\n<span class=\"token number\">1</span>      \tMon May  <span class=\"token number\">9</span> 00:00:00 <span class=\"token number\">2023</span>\tsuperseded\tmy_chart\t<span class=\"token number\">2.2</span>.1      \tUpgrade complete\n<span class=\"token number\">2</span>      \tMon May  <span class=\"token number\">10</span> 00:00:00 <span class=\"token number\">2023</span>\tsuperseded\tmy_chart\t<span class=\"token number\">2.2</span>.1      \tUpgrade complete\n<span class=\"token number\">3</span>      \tMon May  <span class=\"token number\">11</span> 00:00:00 <span class=\"token number\">2023</span>\tsuperseded\tmy_chart\n\n$ helm rollback my_chart <span class=\"token number\">2</span></code></pre></div>\n<h4>Helm Repository</h4>\n<p>다른 사람들이 개발한 Helm Chart를 쉽게 나의 K8S Cluster에 적용 할 수 있습니다. 대표적으로 Apache Airflow에서는 Airflow를 K8S Cluster에 손쉽게 설치 할 수 있도록 <a href=\"https://airflow.apache.org/docs/helm-chart/stable/index.html\">Helm Chart</a>를 제공 하고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ helm repo <span class=\"token function\">add</span> apache-airflow https://airflow.apache.org\n$ helm upgrade <span class=\"token parameter variable\">--install</span> airflow apache-airflow/airflow <span class=\"token parameter variable\">--namespace</span> airflow --create-namespace</code></pre></div>\n<p>이렇게 Helm은 무엇이고, 왜 쓰는지, 그리고 Helm의 기능은 무엇이 있는지 간단하게 알아 보았습니다.</p>\n<h3>Reference</h3>\n<ul>\n<li><a href=\"https://helm.sh/\">Official Helm Homepage</a></li>\n</ul>","id":"8ef2f1ec-bc6d-5cbe-923c-ab49bb89e68e","frontmatter":{"date":"2024-03-01","path":"/cloud-computing/what-is-helm","title":"Helm이란 무엇 인가?","tags":["Cloud-Computing"],"keyword":"Helm, Kubernetes","summary":"K8S의 Package Manager인, Helm에 대해 알아보자.","img":"/post_image/thumbnail/what-is-helm.png","series":null}}},"pageContext":{"postPath":"/cloud-computing/what-is-helm","series":{"data":{"allMarkdownRemark":{"edges":[]}}},"categoryPosts":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"8ef2f1ec-bc6d-5cbe-923c-ab49bb89e68e","excerpt":"Intro 안녕하세요! JustKode, 박민재입니다. 오늘은 K8S Package Manager인 Helm에 대해 알아 보도록 하겠습니다. 우리는 K8S로 서비스를 서빙하기 위해, k8s yaml 파일을 이용하여, K8S Resource (, , , , ,  등)를 관리 하게 됩니다. 하지만, 우리는 실제 서비스를 운영 하는데 다음과 같은 상황을 마주치게 됩니다. 여러 개의 K8S Resource를 K8S Cluster…","frontmatter":{"date":"2024-03-01","tags":["Cloud-Computing"],"path":"/cloud-computing/what-is-helm","title":"Helm이란 무엇 인가?","img":"/post_image/thumbnail/what-is-helm.png","summary":"K8S의 Package Manager인, Helm에 대해 알아보자."}}},{"node":{"id":"1d3523cc-7eb7-5c50-b2e6-b6f6a29170a6","excerpt":"안녕하세요? 오늘은 Kubernetes의 Resource들에 대해서 알아 보도록 하겠습니다. Pod Generator Pod: Pod은 k8s에서 사용되는 가장 작은 배포 단위로, 하나 이상의 container로 구성 됩니다. Pod 내의 container들은 동일 호스트에서 실행 됩니다. ReplicaSet: Pod의 복제본을 관리하는 k8s 객체이며, 지정된 수의 Pod 복제본이 주어진 시간안에 실행 되게 합니다. Deployment…","frontmatter":{"date":"2023-04-30","tags":["Cloud-Computing"],"path":"/cloud-computing/k8s-resources","title":"Kubernetes Resources 요약","img":"/post_image/thumbnail/k8s-resources.png","summary":"k8s의 리소스들을 요약 해 보자."}}},{"node":{"id":"c1eb4e80-b9af-55ff-b567-d3da1576afab","excerpt":"안녕하세요? 오늘은 Kubernetes를 구동 시키기 위해서 필요한 기본적인 Components들에 대해서 요약해서 알아보는 시간을 가져 보도록 하겠습니다. (글 매우 짧고, 성의 없음 주의) Control Plane Component…","frontmatter":{"date":"2023-04-24","tags":["Cloud-Computing"],"path":"/cloud-computing/k8s-components","title":"Kubernetes Component 요약","img":"/post_image/thumbnail/k8s-components.png","summary":"k8s의 컴포넌트를 초간단 요약 해 보자."}}},{"node":{"id":"28baf728-0bd2-5147-9ef0-b05da0826d77","excerpt":"저번 시간에는 Spark On Kubernetes에 대한 이론을 배웠습니다. 오늘은 Spark On Kubernetes에 대한 실습을 진행 하도록 하겠습니다. 사전 준비 Docker Minikube (Kubernetes 1.20 버전 이상) kubectl Spark 3.0 버전 이상 최신 버전일 수록 좋습니다. 얼마 전에 구형 Docker가 깔려 있는 맥북에서 진행을 해 봤는데 Pod이 생성이 안되더군요.. Pyspark Image Build…","frontmatter":{"date":"2023-03-30","tags":["Data-Engineering","Cloud-Computing"],"path":"/data-engineering/spark-on-k8s-2","title":"Spark on Kubernetes - Practice","img":"/post_image/thumbnail/spark-on-k8s-2.png","summary":"Spark를 Kubernetes Cluster에서 동작 시켜 보자."}}}]}}}}},"staticQueryHashes":["3819017183","63159454"],"slicesMap":{}}