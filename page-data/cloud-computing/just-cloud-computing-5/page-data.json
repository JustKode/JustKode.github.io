{"componentChunkName":"component---src-layouts-post-layout-tsx","path":"/cloud-computing/just-cloud-computing-5/","result":{"data":{"markdownRemark":{"html":"<h2>Docker Basic</h2>\n<p>안녕하세요? <strong>JustKode</strong> 입니다. 오늘은 <strong>컨테이너</strong> 기술을 구현하기 위한 <strong>Docker</strong>의 사용법에 대해서 배워보는 시간을 가져 보도록 하겠습니다.</p>\n<p>오리엔테이션에서 <strong>컨테이너 방식으로 프로세스를 격리하여</strong> 실행하는 방식이 대두 되기 시작 했다고 이야기 했었습니다. <strong>커널을 공유</strong>함으로써 가상화에 많은 자원을 사용하지 않으며, 비슷한 종속성을 가진 컨테이너 끼리는 이미지 자원을 공유하여 최적화 합니다. 또한, 동일한 환경에서 프로세스가 실행 될 수 있도록 하면서 충돌이 일어나지 않도록 프로세스를 구성합니다.</p>\n<p align=\"center\">\n\t<img src=\"/post_image/just-cloud-computing/05-02.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\t출처: Docker 홈페이지\n\t</p>\n</p>\n<p>이러한 가상화 기술을 통해 우리는 프로세스 독립 실행을 통해, 어느 환경에서든 프로그램을 실행 할 수 있게 되었습니다. 하지만, 독립적인 OS를 실행 시킴으로써 오는 <strong>Overhead</strong>는 감안 해야 겠지만요. 그럼에도 우리는 <strong>컨테이너</strong>를 실행 함으로써, <strong>로드 밸런싱, Health Check, 예측 가능한 실행 환경</strong>을 가져 갈 수 있다는 점은, 매우 큰 장점으로 작용 합니다.</p>\n<h2>Docker CLI</h2>\n<p>일단, <strong>Docker</strong>를 사용 하기 전, <strong>Docker CLI</strong>를 설치하여야 합니다. 운영 체제에 맞게, 아래 링크에 접속하여 설치 해 주세요.</p>\n<ul>\n<li>Windows: <a href=\"https://docs.docker.com/docker-for-windows/install/\">https://docs.docker.com/docker-for-windows/install/</a></li>\n<li>Mac: <a href=\"https://docs.docker.com/docker-for-mac/install/\">https://docs.docker.com/docker-for-mac/install/</a></li>\n<li>Ubuntu: <a href=\"https://docs.docker.com/engine/install/ubuntu/\">https://docs.docker.com/engine/install/ubuntu/</a></li>\n</ul>\n<h2>Docker Image</h2>\n<p>먼저 <strong>Docker Image</strong>에 대해서 설명 드리겠습니다. <strong>Docker Image</strong>는 <strong>Docker Container</strong>를 만들기 위한, <strong>실행 파일</strong> 이라고 생각하면 됩니다. 우리는 <strong>Docker Image</strong>를 어디서 찾아 볼 수 있을까요? 우리는 이를 <a href=\"https://hub.docker.com/search?q=&#x26;type=image\">Docker Hub</a>에서 찾아 볼 수 있습니다.</p>\n<p align=\"center\">\n\t<img src=\"/post_image/just-cloud-computing/05-01.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\tDocker Hub\n\t</p>\n</p>\n<p>저는 <strong>Nginx 이미지</strong>를 검색 하여 선택 해 보겠습니다. 그럼 다음과 같이 <strong>Nginx 이미지 관련 정보</strong>를 열람 할 수 있습니다.</p>\n<p align=\"center\">\n\t<img src=\"/post_image/just-cloud-computing/05-03.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\tNginx 이미지\n\t</p>\n</p>\n<p>그 다음으로, 조금 밑에 내리다 보면 우리는 다음 이미지의 <strong>버전 정보</strong>를 확인 할 수 있습니다. 여기에 활성화 된 버전 정보를 이용하여, 우리는 이미지를 생성 할 수 있습니다.</p>\n<p align=\"center\">\n\t<img src=\"/post_image/just-cloud-computing/05-04.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\tNginx 이미지 버전 정보\n\t</p>\n</p>\n<p>이제 <strong>Docker CLI</strong>에 접근 할 시간입니다. 터미널에서 <code class=\"language-text\">docker --version</code>을 입력 하여, 도커가 정상적으로 설치 되었는지 확인 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker --version\nDocker version 20.10.6, build 370c289</code></pre></div>\n<p>자, 우리는 일단 <code class=\"language-text\">docker pull</code> 명령어를 통해서 이미지를 가져 오도록 하겠습니다. 우리는 <strong>nginx</strong>의 특정 버전인 <strong>1.20</strong>을 Pull 해 보도록 하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker pull nginx:1.20\n1.20: Pulling from library/nginx\n513c6babab2b: Pull complete \n91772348f9ab: Pull complete \n846cdab430d1: Pull complete \na4a7291136de: Pull complete \n6b72e4ce657e: Pull complete \ne40ce1e39e7d: Pull complete \nDigest: sha256:cd108d06120a7c0d3d073ba4e3eee7b5e6759f0c8a80799e2dbb35d07388840c\nStatus: Downloaded newer image for nginx:1.20\ndocker.io/library/nginx:1.20</code></pre></div>\n<p>그 다음 <strong>Docker Image</strong>를 잘 가져 왔는지 확인 해 볼까요? <code class=\"language-text\">docker image ls</code>를 이용하여 현재 있는 <strong>Docker Image</strong>를 확인 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker image ls\nREPOSITORY   TAG       IMAGE ID       CREATED       SIZE\nnginx        1.20      807dc38084a8   11 days ago   126MB</code></pre></div>\n<h2>Docker Container</h2>\n<p>이미지를 가져왔으니, 이제 이 이미지를 이용하여 <strong>Docker Container</strong>를 만들 차례 입니다. <code class=\"language-text\">docker run [image]</code>을 이용하여, 현재 가지고 있는 <strong>Docker Image</strong>를 이용하여, 컨테이너를 생성 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker run -d -p 8080:80 --name my_nginx nginx:1.20\n5dfb45ecb86a8b4b51e76cda29c1dbfba3d0752a5fbf999f8fb1a1ae7ad37b1d</code></pre></div>\n<p>일단 주로 쓰이는 옵션에 대해서 설명 드리겠습니다.</p>\n<ul>\n<li><code class=\"language-text\">run</code>: 컨테이너를 실행 합니다.</li>\n<li><code class=\"language-text\">-d</code>: 컨테이너를 <strong>detached mode</strong>, 즉, <strong>백그라운드에서 실행</strong> 한다는 뜻입니다.</li>\n<li><code class=\"language-text\">-p 8080:80</code>: 호스트의 8080번 포트를 컨테이너의 80번 포트에 mapping 한다는 뜻입니다.</li>\n<li><code class=\"language-text\">--name my_nginx</code>: <code class=\"language-text\">--name</code> 옵션을 이용해, 실행 할 <strong>컨테이너의 이름</strong>을 설정 합니다. 위 코드는 <strong>컨테이너의 이름</strong>을 <strong>my_nginx</strong>로 설정 합니다.</li>\n<li><code class=\"language-text\">nginx:1.20</code>: 저희가 사용할 이미지 입니다. 해당 이미지가 설치 되어 있지 않다면, 설치합니다.</li>\n</ul>\n<p>우리는 이 과정을 통해 이미지를 간단하게 컨테이너로 실행 할 수 있었습니다. <a href=\"http://localhost:8080\">http://localhost:8080</a> 에 접속하면 다음과 같은 화면을 볼 수 있습니다.</p>\n<p align=\"center\">\n\t<img src=\"/post_image/just-cloud-computing/05-05.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\tNginx의 성공적 실행\n\t</p>\n</p>\n<p><code class=\"language-text\">docker ps</code>를 입력 하면, 현재 실행 중인 컨테이너를 확인 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">CONTAINER ID   IMAGE        COMMAND                  CREATED         STATUS         PORTS                                   NAMES\n5dfb45ecb86a   nginx:1.20   &quot;/docker-entrypoint.…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp   my_nginx</code></pre></div>\n<p>만약 잠시 <strong>컨테이너의 프로세스는 종료</strong> 하면서, <strong>스냅샷</strong> (컨테이너 내 설정 및 파일 정버)을 남기고 싶을 땐, <code class=\"language-text\">docker stop [컨테이너 명 | 컨테이너 아이디]</code>을 이용 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker stop my_nginx\nmy_nginx</code></pre></div>\n<p><code class=\"language-text\">docker ps -a</code>를 이용하여, 모든 상태의 컨테이너를 확인 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker ps -a\nCONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS                          PORTS     NAMES\n5dfb45ecb86a   nginx:1.20   &quot;/docker-entrypoint.…&quot;   15 minutes ago   Exited (0) About a minute ago             my_nginx</code></pre></div>\n<p>다시 실행 하기를 원하신다면, <code class=\"language-text\">docker start [컨테이너 명 | 컨테이너 아이디]</code>를 이용 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker start my_nginx\nmy_nginx\n$ docker ps\nCONTAINER ID   IMAGE        COMMAND                  CREATED       STATUS          PORTS                                   NAMES\n5dfb45ecb86a   nginx:1.20   &quot;/docker-entrypoint.…&quot;   5 hours ago   Up 12 seconds   0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp   my_nginx</code></pre></div>\n<p>만약, 프로세스 실행 상태를 저장하면서 잠깐 일시 정지, 다시 실행을 하고 싶을 때는 위의 방식과 비슷하게 각각 <code class=\"language-text\">docker pause [컨테이너 명 | 컨테이너 아이디]</code>, <code class=\"language-text\">docker unpause [컨테이너 명 | 컨테이너 아이디]</code>를 입력 하면 됩니다.</p>\n<p>더 이상 컨테이너가 필요 하지 않게 되었다면, <code class=\"language-text\">docker kill [컨테이너 명 | 컨테이너 아이디]</code>을 이용하여 제거 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker kill my_nginx\nmy_nginx\n$ docker ps -a\nCONTAINER ID   IMAGE        COMMAND                  CREATED        STATUS                       PORTS     NAMES</code></pre></div>\n<h2>Docker Container Access</h2>\n<p>우리는 Docker Container에 어떻게 Access 할 수 있을까요? 우리는 이를 <code class=\"language-text\">docker exec -it [컨테이너 명 | 컨테이너 아이디] [실행 할 파일]</code>을 이용해서 컨테이너 내부 파일에 접근 할 수 있습니다.</p>\n<p>다시 <code class=\"language-text\">docker run -d -p 8080:80 --name my_nginx nginx:1.20</code> 를 입력 해 주신 다음, <code class=\"language-text\">docker exec -it my_nginx /bin/bash</code>를 입력 해 주세요. 그럼 다음과 같이 실행 중인 컨테이너 내로 접속 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker exec -it my_nginx /bin/bash\nroot@5dfb45ecb86a:/#</code></pre></div>\n<h2>DockerFile</h2>\n<p>이런 기존의 이미지로 만든 컨테이너를 직접 실행 한 다음, 컨테이너에 접속해서 환경 설정을 직접 해도 되지만, 이런 식으로 하게되면, 배포가 쉽다는 컨테이너의 장점을 이용하지 못하게 됩니다. 이때, 우리는 어떻게 할 수 있을까요?</p>\n<p>이럴 때는, <strong>DockerFile</strong> 을 이용하면 됩니다. <strong>DockerFile</strong>은 어떻게 이미지를 구현 할 건지에 대한 내용들을 구성 할 수 있습니다. <strong>Django 서버를 여는</strong> 예제를 통해서 같이 보겠습니다. 일단 실습을 하기 전 아무 폴더나 만든 후에 다음을 작성해 주세요.</p>\n<p>첫 번째로 <strong>Dockerfile</strong>을 만드는 예제 입니다. 만드신 폴더에 <code class=\"language-text\">Dockerfile</code> 이라는 이름으로 파일을 만든 후, 다음을 입력 해 주세요.</p>\n<ul>\n<li>DockerFile</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> python:3.9</span>\n<span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 8000</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENV</span> mode=<span class=\"token string\">\"development\"</span></span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> /app /app</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> pip install -r requirements.txt <span class=\"token operator\">\\</span>\n    &amp;&amp; django-admin startproject mysite . <span class=\"token operator\">\\</span>\n    &amp;&amp; python manage.py makemigrations <span class=\"token operator\">\\</span>\n    &amp;&amp; python manage.py migrate</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> python manage.py runserver 0.0.0.0:8000</span></code></pre></div>\n<p>두 번째는 파이썬 의존성 정보를 담을 <code class=\"language-text\">requirements.txt</code> 입니다. 예시 이므로, app 폴더를 만들어, 해당 이름에 <code class=\"language-text\">django</code>만 넣도록 하게 하겠습니다.</p>\n<ul>\n<li>app/requirements.txt</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">django</code></pre></div>\n<p>각 명령어의 역할 입니다.</p>\n<ul>\n<li><code class=\"language-text\">FROM</code>: <strong>DockerFile</strong>을 <strong>Docker Image</strong>로 빌드 시, 기반이 되는 <strong>Docker Image</strong>를 설정 합니다.</li>\n<li><code class=\"language-text\">EXPOSE</code>: 컨테이너의 어느 포트를 외부로 노출 시킬 것인지 설정 합니다.</li>\n<li><code class=\"language-text\">ENV</code>: 환경 변수를 설정 합니다. 키=\"값\" 형태로 삽입 합니다.</li>\n<li><code class=\"language-text\">COPY</code>: 첫 번째 인자로 들어간 폴더를, 두 번째 인자로 들어간 위치에 복사 합니다.</li>\n<li><code class=\"language-text\">WORKDIR</code>: 현재 사용 폴더를 해당 폴더로 이동 시킵니다.</li>\n<li><code class=\"language-text\">RUN</code>: 빌드를 하기 위해 필요한 명령어를 작성합니다. 여기에는 <code class=\"language-text\">apt-get</code>, <code class=\"language-text\">npm</code>, <code class=\"language-text\">pip</code> 등의 명령어를 삽입하여, <strong>Docker Image</strong>를 만드는데 필요한 의존성 파일들을 설치하고, 사전 실행이 필요한 명령어를 사용 하는데 많이 사용합니다.</li>\n<li><code class=\"language-text\">CMD</code>: <code class=\"language-text\">docker run</code>을 통해 실행 했을때, 기본적으로 실행 될 명령어를 입력 합니다.</li>\n</ul>\n<p>이렇게 입력 한 후, <code class=\"language-text\">docker build</code>를 통해, 해당 폴더에 있는 <code class=\"language-text\">Dockerfile</code>에 작성 한 내용대로, <strong>Docker Image Build</strong>를 실행 합니다. <code class=\"language-text\">-t</code> 옵션을 통해 이미지의 이름을 설정 해 줄 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker build -t mydjango .</code></pre></div>\n<p>그 다음 만들어진 이미지를 이용해, <code class=\"language-text\">docker run</code> 으로, 컨테이너를 생성 후 실행 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"terminal\"><pre class=\"language-terminal\"><code class=\"language-terminal\">$ docker run -d -p 8080:8000 mydjango</code></pre></div>\n<p><a href=\"http://localhost:8080\">http://localhost:8080</a> 에 접속하면 다음과 같은 화면을 볼 수 있습니다.</p>\n<p align=\"center\">\n\t<img src=\"/post_image/just-cloud-computing/05-06.png\" width=\"300px\"/>\n\t<p align=\"center\" style=\"color:#888888; font-size: 12px;\">\n\t\tDjango 서버의 성공 적 실행\n\t</p>\n</p>\n<h2>마치며</h2>\n<p>이렇게 <strong>Docker</strong>에 대해서 간단하게 다루어 보는 시간을 가졌습니다. 다음 시간에는, Container Orchestration을 위한 <strong>Kubernetes</strong>에 대해서 배워 보는 시간을 가져 보도록 하겠습니다!</p>","id":"4eaf7068-4945-5c51-8c8c-5824b4322d91","frontmatter":{"date":"2021-08-02","path":"/cloud-computing/just-cloud-computing-5","title":"[찍먹 Cloud Computing] 5. Docker Image, Container, Dockerfile","tags":["Cloud-Computing"],"keyword":"Cloud Computing, Docker, Docker Image, Docker Container, Dockerfile","summary":"도커의 기본 사용법에 대해서 알아보자.","img":"/post_image/thumbnail/just-cloud-computing-5.jpg","series":"찍먹 Cloud Computing"}}},"pageContext":{"postPath":"/cloud-computing/just-cloud-computing-5","series":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"caefa963-6e15-52e9-9517-f7f21f7f83be","excerpt":"Kubernetes 안녕하세요! 오늘은 Kubernetes에 대해서 배워 보는 시간을 가져 보도록 하겠습니다. 일단 Kubernetes에 대해 알아 보기 전에, Container Orchestration에 대해서 먼저 알아 보도록 하겠습니다. Container Orchestration…","frontmatter":{"date":"2021-08-17","tags":["Cloud-Computing"],"path":"/cloud-computing/just-cloud-computing-6","title":"[찍먹 Cloud Computing] 6. Kubernetes","img":"/post_image/thumbnail/just-cloud-computing-6.jpg","summary":"쿠버네티스에 대해서 알아보자."}}},{"node":{"id":"4eaf7068-4945-5c51-8c8c-5824b4322d91","excerpt":"Docker Basic 안녕하세요? JustKode 입니다. 오늘은 컨테이너 기술을 구현하기 위한 Docker…","frontmatter":{"date":"2021-08-02","tags":["Cloud-Computing"],"path":"/cloud-computing/just-cloud-computing-5","title":"[찍먹 Cloud Computing] 5. Docker Image, Container, Dockerfile","img":"/post_image/thumbnail/just-cloud-computing-5.jpg","summary":"도커의 기본 사용법에 대해서 알아보자."}}},{"node":{"id":"e2205b1b-8c97-5e6f-be7e-095f386a1379","excerpt":"AWS의 Database 안녕하세요? Justkode 입니다. 이번 시간에는 AWS의 Database에 대해서 공부 해 보는 시간을 가져 보도록 하겠습니다. AWS에서 사용하는 Database는 두 가지가 있습니다. DynamoDB 첫 번째는 DynamoDB 입니다. 이는 AWS의 대표격으로 사용 되는 데이터베이스이며, NoSQL Database 중 하나 입니다. 여기서 NoSQL은 무엇이냐 하면, 말 그대로 표준 SQL…","frontmatter":{"date":"2021-07-27","tags":["Cloud-Computing"],"path":"/cloud-computing/just-cloud-computing-4","title":"[찍먹 Cloud Computing] 4. DynamoDB & Amazon RDS","img":"/post_image/thumbnail/just-cloud-computing-4.jpg","summary":"두 개의 대표적인 AWS DB를 공부 해 보자"}}},{"node":{"id":"ac18d925-067a-5f23-a7bb-b00fd02c6b60","excerpt":"AWS Lambda 안녕하세요? Justkode 입니다. 이번 시간에는 AWS Lambda에 대해서 알아 보고, AWS Lambda 함수를 생성 해 보고, 이를 AWS API Gateway를 통해 연결 하여 사용 해 보는 시간을 가져 보도록 하겠습니다. AWS Lambda에 대해서 간단하게 설명 하고 넘어 가자면, **PaaS (Platform As A Service)**의 일종으로, 우리가 AWS Lambda에 우리가 구현한 API Code…","frontmatter":{"date":"2021-07-21","tags":["Cloud-Computing"],"path":"/cloud-computing/just-cloud-computing-3","title":"[찍먹 Cloud Computing] 3. AWS Lambda","img":"/post_image/thumbnail/just-cloud-computing-3.jpg","summary":"Python 기반으로 AWS Lambda 함수를 만들어보자."}}},{"node":{"id":"a970f978-c18b-5e60-9833-49bb2a24e0fa","excerpt":"AWS S3 안녕하세요? Justkode 입니다. 이번 시간에는 AWS S3에 대해서 알아 보고, AWS S3 버킷 생성, 파일 접근 권한 설정, Python 코드 상에서의 접근을 해 보도록 하겠습니다. 일단 AWS S3에 대해서 간단하게 설명 드리겠습니다. AWS S…","frontmatter":{"date":"2021-07-16","tags":["Cloud-Computing","Python"],"path":"/cloud-computing/just-cloud-computing-2","title":"[찍먹 Cloud Computing] 2. AWS S3","img":"/post_image/thumbnail/just-cloud-computing-2.jpg","summary":"AWS S3와 boto3를 사용 해 보자"}}},{"node":{"id":"42bfd111-c953-556a-9bc2-1b915f83b767","excerpt":"AWS EC2 안녕하세요? Justkode 입니다. 이번 시간에는 AWS EC2에 대해서 알아 보고, AWS EC…","frontmatter":{"date":"2021-07-06","tags":["Cloud-Computing"],"path":"/cloud-computing/just-cloud-computing-1","title":"[찍먹 Cloud Computing] 1. AWS EC2란? / AWS EC2 인스턴스 만들기","img":"/post_image/thumbnail/just-cloud-computing-1.jpg","summary":"AWS EC2 인스턴스를 만들어 보자."}}},{"node":{"id":"0f0dbc8c-b2d6-51c3-895e-f300be8991d8","excerpt":"Cloud Computing? 안녕하세요? Justkode 입니다. Cloud Computing…","frontmatter":{"date":"2021-06-25","tags":["Cloud-Computing"],"path":"/cloud-computing/just-cloud-computing-0","title":"[찍먹 Cloud Computing] 0. Orientation","img":"/post_image/thumbnail/just-cloud-computing-0.jpg","summary":"Cloud Computing을 찍먹해 보자."}}}]}}},"categoryPosts":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"91df27ea-39c5-50a2-8365-cab69a8a38a0","excerpt":"Intro 안녕하세요! JustKode, 박민재입니다. 오늘은 K8S Package Manager인 Helm에 대해 알아 보도록 하겠습니다. 우리는 K8S로 서비스를 서빙하기 위해, k8s yaml 파일을 이용하여, K8S Resource (, , , , ,  등)를 관리 하게 됩니다. 하지만, 우리는 실제 서비스를 운영 하는데 다음과 같은 상황을 마주치게 됩니다. 여러 개의 K8S Resource를 K8S Cluster…","frontmatter":{"date":"2024-03-01","tags":["Cloud-Computing"],"path":"/cloud-computing/what-is-helm","title":"Helm이란 무엇 인가?","img":"/post_image/thumbnail/what-is-helm.png","summary":"K8S의 Package Manager인, Helm에 대해 알아보자."}}},{"node":{"id":"f2c9a587-fb7c-5963-8398-3ad7356ae23d","excerpt":"안녕하세요? 오늘은 Kubernetes의 Resource들에 대해서 알아 보도록 하겠습니다. Pod Generator Pod: Pod은 k8s에서 사용되는 가장 작은 배포 단위로, 하나 이상의 container로 구성 됩니다. Pod 내의 container들은 동일 호스트에서 실행 됩니다. ReplicaSet: Pod의 복제본을 관리하는 k8s 객체이며, 지정된 수의 Pod 복제본이 주어진 시간안에 실행 되게 합니다. Deployment…","frontmatter":{"date":"2023-04-30","tags":["Cloud-Computing"],"path":"/cloud-computing/k8s-resources","title":"Kubernetes Resources 요약","img":"/post_image/thumbnail/k8s-resources.png","summary":"k8s의 리소스들을 요약 해 보자."}}},{"node":{"id":"f55c467d-2b09-54d6-bc08-b0b08f536b86","excerpt":"안녕하세요? 오늘은 Kubernetes를 구동 시키기 위해서 필요한 기본적인 Components들에 대해서 요약해서 알아보는 시간을 가져 보도록 하겠습니다. (글 매우 짧고, 성의 없음 주의) Control Plane Component…","frontmatter":{"date":"2023-04-24","tags":["Cloud-Computing"],"path":"/cloud-computing/k8s-components","title":"Kubernetes Component 요약","img":"/post_image/thumbnail/k8s-components.png","summary":"k8s의 컴포넌트를 초간단 요약 해 보자."}}},{"node":{"id":"7611f6af-dc48-595b-8866-23beee4d5cda","excerpt":"저번 시간에는 Spark On Kubernetes에 대한 이론을 배웠습니다. 오늘은 Spark On Kubernetes에 대한 실습을 진행 하도록 하겠습니다. 사전 준비 Docker Minikube (Kubernetes 1.20 버전 이상) kubectl Spark 3.0 버전 이상 최신 버전일 수록 좋습니다. 얼마 전에 구형 Docker가 깔려 있는 맥북에서 진행을 해 봤는데 Pod이 생성이 안되더군요.. Pyspark Image Build…","frontmatter":{"date":"2023-03-30","tags":["Data-Engineering","Cloud-Computing"],"path":"/data-engineering/spark-on-k8s-2","title":"Spark on Kubernetes - Practice","img":"/post_image/thumbnail/spark-on-k8s-2.png","summary":"Spark를 Kubernetes Cluster에서 동작 시켜 보자."}}}]}}}}},"staticQueryHashes":["3819017183","63159454"],"slicesMap":{}}